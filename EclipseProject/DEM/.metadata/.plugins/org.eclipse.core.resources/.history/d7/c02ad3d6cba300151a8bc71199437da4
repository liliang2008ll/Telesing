	/*******************************************************************
 *  Copyright(c) 2015-2017 Nanjing telesing
 *  All rights reserved.
 *
 *  文件名称: core
 *  简要描述: acomms 核心算法对interface接口封装类库
 *
 *  当前版本:1.1
 *  作   者:Lee.liang
 *  日   期:
 *  说   明:
 *
 *  取代版本:1.0
 *  作   者:
 *  日   期:
 *  说   明:
 ******************************************************************/
#include <stdio.h>
#include "core.h"
#include  "dem.h"
#include "tlib.h"
#include "core.h"

#include "openssl\rsa.h"
#include "openssl\err.h"
#include "openssl\pem.h"
#include <stdio.h>
#include <string.h>
#include "openssl\crypto.h"
#include "openssl\rand.h"
#include "openssl\bn.h"

#define SetKey \
				key->n = BN_bin2bn(n, sizeof(n)-1, key->n); \
				key->e = BN_bin2bn(e, sizeof(e)-1, key->e); \
				key->d = BN_bin2bn(d, sizeof(d)-1, key->d); \
				key->p = BN_bin2bn(p, sizeof(p)-1, key->p); \
				key->q = BN_bin2bn(q, sizeof(q)-1, key->q); \
				key->dmp1 = BN_bin2bn(dmp1, sizeof(dmp1)-1, key->dmp1); \
				key->dmq1 = BN_bin2bn(dmq1, sizeof(dmq1)-1, key->dmq1); \
				key->iqmp = BN_bin2bn(iqmp, sizeof(iqmp)-1, key->iqmp); \
				return 0;

static int key5(RSA *key)
{
    //密钥中变量
    static unsigned char n[] =
        "\x9c\xb5\xd4\x87\x70\xb6\x43\x03\x49\x5e\xe8\x40\xbc\xbf\x15\x79\x9e\xb2\x18\x0d\xfa\xde\xf7\xb2\x37\xd0\x22\xdb\xd4\xef\x2d\x79\x63\xdb\x38\x2b\xed\x05\xe5\x14\x0b\x9a\x80\x5c\x75\x11\xef\x1b\x89\x5b\x40\xb7\x1c\x22\x7d\x84\x59\xbc\xcc\xb5\xca\x63\xbd\x7b\xdf\x1e\x3a\x72\x13\x86\x93\xa9\x9c\xc7\xcb\x48\x3d\x8b\x8c\xa9\x4c\xce\xd7\xca\xc0\xb0\x62\x7a\x95\x7a\xd7\xbd\x27\x82\x91\x40\x90\x35\xb1\xe4\xab\x5f\xbb\x06\x29\x01\xf4\x91\xe5\x15\x5f\xd3\xc2\x13\x38\xaf\x1f\x75\x88\x47\xd1\x04\xd2\xb3\x71\xa0\x9e\xc7";

    static unsigned char e[] = "\x00\x01\x00\x01";

    static unsigned char d[] =
        "\x09\x33\x83\xef\x0f\xe7\x23\xb8\x25\xae\xb4\xe4\x58\x30\xc0\x0a\x0c\x0f\x58\xea\x39\x38\xae\x42\x80\x94\x6f\xf7\x88\x61\x22\xc2\x65\xe2\x91\x41\xc3\x00\xfd\x9a\x57\xb4\x12\xa5\x5b\x1a\x5a\x77\xbb\x70\xe8\x33\xd8\x2b\x0e\x43\x9f\x21\x3e\xc3\xcd\xc6\x5d\x71\xb8\xec\x6e\xea\x5f\x17\xa5\xe1\x43\xeb\xdd\x71\xa4\x6f\xed\x09\xf0\x8b\xbe\xd9\x26\xb5\x70\x9b\xab\x42\x70\x70\x71\xd4\x14\x8f\xa8\x2c\xc4\x23\x21\x70\x1f\xd7\xef\xfd\x6b\x02\x40\x8b\xf4\x77\x5c\x78\x08\x80\x8b\x7d\x7e\x7a\xb2\x14\xe0\xf6\x94\xf2\x56\x81";

    static unsigned char p[] =
        "\xd6\x8c\xf3\x60\x76\x5b\x6e\x55\xde\x5a\xf7\x43\x95\x6b\x5e\xc0\xd9\x5a\xcd\xd8\x03\xd3\x65\xcb\x1d\xf6\xfe\x57\x39\x6c\xfd\x72\x06\x8b\xe8\x2e\x05\xfd\xe4\x7c\x39\x94\xa2\xea\xb8\x4c\xf5\xd6\xdc\xd7\x9a\xb8\xef\x05\xd9\xef\x96\xfa\x91\xa3\xb6\x9a\xd4\x19";

    static unsigned char q[] =
        "\xba\xfc\x43\xf4\x79\x60\x09\x97\x37\x6e\x55\x83\xbb\xb6\xb3\x5f\x4c\x39\x00\x93\x19\x90\x64\x65\x3a\xf7\xa0\xca\x5e\x9d\x66\xd9\xee\x7d\xdb\xd0\xe2\xe7\x57\x55\x41\x90\xc7\x4b\xed\x91\x42\xea\x34\x93\x1a\x76\xb8\xd0\xf2\x74\xed\xf5\xd3\xb9\xa6\x34\x65\xdf";

    static unsigned char dmp1[] =
        "\x4f\xfd\x89\x17\xa3\xc8\xfe\xe0\x00\xe0\xc5\x63\x6b\x27\xf6\xd1\xcb\xb7\xb1\x1b\x22\x82\x04\x67\xb0\x2a\x50\x35\x50\xf1\xb3\xa4\x79\x90\x5b\xe6\x1c\xd1\xc6\x08\x12\xa7\xb9\xfd\xec\xec\xb4\x93\x81\x0e\xd9\x5e\xad\xae\xee\xcc\x06\xec\x30\xb4\x6a\xf6\x5a\xb1";

    static unsigned char dmq1[] =
        "\x60\x9b\x5d\x70\xbe\x15\x04\x5f\x80\x60\x1d\x06\x86\xc1\x8a\x43\x3e\x5a\x65\x15\x9b\x2b\xa2\xf3\x3a\x58\x1e\x56\xf0\x33\x5a\xa4\x56\x37\xe8\x8e\x2f\xed\x5e\x8d\xc9\xe6\x47\x51\xcf\x58\x31\xbe\x57\x93\x79\x24\xc5\xb0\x0e\xd4\xa2\xed\x53\x8a\xa3\x78\x86\xf9";

    static unsigned char iqmp[] =
        "\x28\xc6\xca\x44\x40\x7a\xad\x4c\x74\x4d\xeb\x2d\xaa\xd7\xc8\x43\xef\x4a\x12\x44\x0a\x89\xb8\x12\x11\x7f\x40\x91\x9a\xe1\x4a\xfe\xe2\xe5\x3e\x6c\x7f\x07\x49\x04\xc9\x95\x8a\x4e\xa5\x7f\x3c\x8f\xea\xbd\x71\x2e\xca\x7a\x37\xdf\x99\x05\x2f\x0c\x03\x11\x6d\x5d";

    SetKey;
}

char* my_encrypt(char *str,char *path_key);//加密
char* my_decrypt(char *str,char *path_key);//解密
//!
//! \brief CORE::cer_encrypt
//! \param input_cer
//! \return
//!
char * CORE::cer_encrypt(char *cer)
{
	int err = 0;
	    int v;
	    RSA *key;
	    unsigned char ptext[256];
	    unsigned char ctext[256];
	    static unsigned char ptext_ex[] = "12345678";
	    unsigned char ctext_ex[256];
	    int plen;
	    int clen = 0;
	    int num;
	    int n;
	    int i;
	    EVP_PKEY *pkey;

	    printf("ptext_ex: %s\n", ptext_ex);
	    {
	        key = RSA_new();
	        key5(key);

	        plen = sizeof(ptext_ex) - 1;
	        num = RSA_private_encrypt(plen, ptext_ex, ctext, key,
	                RSA_PKCS1_PADDING);
	        if (num != 128)   //模数长度
	        {
	            printf("PKCS#1 v1.5 encryption failed!\n");
	            err=1;
	            goto next;
	        }

	        //加密后的数据
	        printf("encrypted text: \n");
	        for (i = 0; i < num; i++)
	        {
	            printf("\\x%02x", ctext[i]);
	        }
	        printf("\n");

	        printf("RSA_private_encrypt num: %d\n", num);

	        num = RSA_public_decrypt(num, ctext, ptext, key,
	                RSA_PKCS1_PADDING);
	        if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
	        {
	            printf("PKCS#1 v1.5 decryption failed!\n");
	            err=1;
	        }
	        else
	            printf("PKCS #1 v1.5 encryption/decryption ok\n");

	        printf("RSA_public_decrypt num: %d\n", num);
	        ptext[num] = '\0';    //字符串结尾
	        printf("ptext: %s\n", ptext);

	next:
	        //公钥和私钥输出为 PEM 格式：
	        PEM_write_RSAPrivateKey(stdout, key, NULL, NULL, 0, NULL, NULL);
	        PEM_write_RSAPublicKey(stdout, key);

	        //释放申请的内存
	        RSA_free(key);
	    }

	    if (err) printf("ERROR: %d\n", err);



	    return 0;


  //  return cer;
}
//!
//! \brief CORE::cer_decrypt
//! \param output_cer
//! \return
//!
char * CORE::cer_decrypt( char *cer)
{
	return cer;
}
//!
//! \brief CORE::cer_bind
//! \param input_cer
//! \param input_cer_len
//! \return Yes or No
int CORE::cer_bind(char *  input_cer, int input_cer_len)
{
    return SUCCEED;
}
//!
//! \brief CORE::cer_unbind
//! \param input_cer
//! \param input_cer_len
//! \return
//!
int CORE::cer_unbind(char *  input_cer, int input_cer_len)
{
    return SUCCEED;
}
//!
//! \brief CORE::cer_isbind
//! \param input_cer
//! \param input_cer_len
//! \return
//!
int CORE::cer_isbind(char *  input_cer, int input_cer_len)
{
    return SUCCEED;
}
//!
//! \brief CORE::cer_section_auth
//! \param input_section
//! \return
//!
int CORE::cer_section_auth(char *  input_section)
{
    return SUCCEED;
}
//!
//! \brief CORE::genr_wave
//! \param input_section
//! \param input_data
//! \param out_genr_result
//! \return
//!
short *CORE::genr_wave(char *  input_section, char *  input_data, int out_genr_result)
{

}
//!
//! \brief CORE::recog_stop
//! \return
//!
int CORE::recog_stop()
{
    stop();
}
//!
//! \brief CORE::recog_start
//! \param input_cfg
//! \return
//!
int CORE::recog_start(Recog_cfg input_cfg)
{
	start();
}
//!
//! \brief CORE::recog_setconfig
//! \param input_cfg
//! \return
//!
int CORE::recog_setconfig(Recog_cfg input_cfg)
{


}
//!
//! \brief CORE::recog_getconfig
//! \param input_cfg
//! \return
//!
int CORE::recog_getconfig(Recog_cfg input_cfg)
{
 // memcpy((void *)input_cfg,(void *)local_cfg,sizeof(local_cfg));
  //  local_cfg.input_buffer_len = input_cfg.b
}
//!
//! \brief CORE::recog_write
//! \param input_data
//! \param input_data_len
//! \return
//!
int CORE::recog_write(short *input_data, int input_data_len)
{
    wirte(input_data,input_data_len);
}
//!
//! \brief CORE::recog_status
//! \param output_status
//! \return
//!
int CORE::recog_status(Recog_status output_status)
{

      return 0;
}

