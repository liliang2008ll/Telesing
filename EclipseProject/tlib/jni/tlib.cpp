#include <stdio.h>
#include <string.h>
#include <jni.h>
#include <assert.h>
#include "net_telesing_tsdk_tlib_Acomms.h"
#include "tlib.h"

#ifdef __cplusplus
extern "C" {
#endif

//***************************************************************************
//!包名称
#define JNIREG_CLASS "net/telesing/tsdk/tlib/Acomms"

//**************************************************************************
#define INFOR(a)   __android_log_print(ANDROID_LOG_INFO, "NATIVE:",a);
//**************************************************************************
//简洁函数名称
//返回值			 JNI指定值
#define JINT	 JNIEXPORT jint JNICALL
#define	JVOID	 JNIEXPORT void JNICALL
#define	JOBJECT	 JNIEXPORT jobject JNICALL
#define	JSTRING  JNIEXPORT jstring JNICALL
//**************************************************************************
//定义数据用于存放JAVA相关参数
typedef struct{

	JavaVM* 	  jvm;			//Java线程
	jobject 	  jobj;
	jclass  	  jclass;
	jmethodID     cb_recog_result; //回调函数列表

     jchar  	  first_start;  	//初始化互斥
     CER		  cer; 			//证书
     Recog_status sys_status;	//状态
     Recog_cfg 	  sys_cfg;	 	//配置
}JAVA;

//回调函数
typedef struct {
	const char* packagename;
	const char* name;
	const char* signature;
} JNICallBackMethod;

//证书签名用结构体
typedef struct {
	const char* name;
	const char* signature;
} CER_INFOR;
//全局的java选项
JAVA *g_java ;


static JNICallBackMethod g_cb_methods[] = {
		{"net/telesing/tsdk/tlib/Acomms","recogResult", "(Ljava/lang/String;Ljava/lang/String;I)V"},
};

//***************************************************************************
//函数名称：callback_java
//函数功能：同步回掉函数
//输入参数： char *section, 	证书段
//			char *data		解析到的数据
//			int times		解析花费时间单位ms
//输出参数： 无
//备	        注 ：
//
//
//**************************************************************************
void callback_java( char *section, char *data,int times){

	JNIEnv* input_env;

	g_java->jvm->AttachCurrentThread(&input_env, NULL);//获取线程环境

	//调用返回值为void的方法
	input_env->CallVoidMethod(  g_java->jobj, g_java->cb_recog_result,
								input_env->NewStringUTF(section),	//传入证书信息
								input_env->NewStringUTF(data),	  	//传入数据信息
								times);							  	//传入时间信息
#ifdef _USED_IN_PTHREAD
	g_java->jvm->DetachCurrentThread();
#endif
}
#if 0
void ndk_test_call_fnx(char *debug_message){
	//@新建字符串用于测试
	JNIEnv* env_;
	char str1[] = "test1,start....";
	char str2[] = "test2,start....";

	globe_JavaVM->AttachCurrentThread(&env_, NULL);

	//找到指定的函数名
	jmethodID mid = env_->GetMethodID(globe_JavaClass, "recogResult", "(Ljava/lang/String;Ljava/lang/String;I)V");
	//调用返回值为void的方法
	env_->CallVoidMethod(globe_JavaObj, mid,env_->NewStringUTF(str1),env_->NewStringUTF(str2),100);

	globe_JavaVM->DetachCurrentThread();
	//状态赋值
	recog_status.output_recog_state  = 100;
	recog_status.output_blank_buffer = 0.2;
	recog_status.output_ss           =0.99;
}



/*
 * Class:     net_telesing_tsdk_tlib_Acomms
 * Method:    startRecog
 * Signature: (Lnet/telesing/tsdk/tlib/Recog_cfg;)I
 */
//(Recog_cfg cfg)
//调试
JNIEXPORT jint JNICALL Java_net_telesing_tsdk_tlib_Acomms_startRecog
  (JNIEnv *input_env, jobject input_obj, jobject recog_cfg){

	__android_log_print(ANDROID_LOG_INFO, "NDK:","START RECONG");

	//获取Java中的实例类
	jclass objectClass = input_env->FindClass("net/telesing/tsdk/tlib/Recog_cfg");


	//获取类中每一个变量的定义
	jfieldID  jgap      = input_env->GetFieldID(objectClass, "gap", "I");
	jfieldID  jpoints   = input_env->GetFieldID(objectClass, "fft_points", "I");

	//改变结构体变量中的数值
	//input_env->SetIntField(recog_cfg,fft_gap,100);
	//获取结构体变量中int类型的变量值
	jint  temp_gap = input_env->GetIntField(recog_cfg,jgap);


	__android_log_print(ANDROID_LOG_INFO, "NDK:","gap = : %d", temp_gap);

	return 0;

}

/*
 * Class:     net_telesing_tsdk_tlib_Acomms
 * Method:    getRecogStatus
 * Signature: ()Lnet/telesing/tsdk/tlib/Recog_status;
 */
JNIEXPORT jobject JNICALL Java_net_telesing_tsdk_tlib_Acomms_getRecogStatus
  (JNIEnv *input_env, jobject obj)
{
	//获取JAVA中的实例类
	 jclass objectClass = (input_env)->FindClass("net/telesing/tsdk/tlib/Recog_status");

	 //获取类中每一个变量的定义
	jfieldID j_ss			 = input_env->GetFieldID(objectClass, "ss", "D");
	jfieldID j_blank_buffer  = input_env->GetFieldID(objectClass, "blankBuffer", "D");
	jfieldID j_recog_stat    = input_env->GetFieldID(objectClass, "recogStat", "I");

	//修改状态值准备JAVA获取
	//状态赋值
	recog_status.output_recog_state  = 100;
	recog_status.output_blank_buffer = 0.2;
	recog_status.output_ss           = 0.99;

	//新建一个对象用于返回到Java中
	jobject status = input_env->AllocObject(objectClass);

	//给每一个实例的变量
	input_env -> SetDoubleField(status, j_ss,recog_status.output_ss  );
	input_env -> SetDoubleField(status, j_blank_buffer,recog_status.output_blank_buffer);
	input_env -> SetIntField(status, j_recog_stat,recog_status.output_recog_state );

	return status;
}
#endif
//***************************************************************************
//函数名称：GetClassMethodID
//函数功能：根据函数名和参数列表找到回调函数ID
//输入参数： JNIEnv* env:						线程环境
//			const char* class_pathName,     类名称
//			const char* function_Name,		函数名称
//			const char* arg_format			函数参数签名
//
//输出参数：用于保存的方法的ID，返回值保存下来的一定是全局变量
//备	         注 ：
//			由于NDK的BUG，该函数的返回值回一直整个程序的生命周期
//			 relese
//			去掉错误提示信息
//**************************************************************************
static jmethodID get_class_method_id( JNIEnv* env,
								  	  const char* class_pathName,
									  const char* function_Name,
									  const char* arg_format
									)
{
	jclass clazz = env->FindClass(class_pathName); //classPathName完整的包名加类名

	jmethodID j_callback = env->GetMethodID(clazz, function_Name, arg_format); //获取java层方法id

	return j_callback;
}

//***************************************************************************
//函数名称：native_getRecogStatus
//函数功能：测试用绑定本地函数
//输入参数：
//输出参数：
//备	         注 ：
//			1.去掉系统自动生成的函数名前缀
//			2.测试保存全局的环境变量和方法的ID
//			3.测试全局回调函数
//			4.测试全局变量数据结构体
//			5.测试JAVA结构体参数输入,
//			6.测试C结构体作为返回值
//
//**************************************************************************
JOBJECT native_get_recog_status(JNIEnv *input_env, jobject obj)
{

	//开机运行,执行初始化动作
	if(0 == g_java->first_start){

		//获取JVM虚拟机并且保存在全局变量中
		input_env->GetJavaVM(&g_java->jvm);
		//@获取对象
		g_java->jobj = input_env->NewGlobalRef(obj);

		jclass javaClass = input_env->GetObjectClass(obj);
		//@对象转为全局引用
		g_java->jclass = (jclass)input_env->NewGlobalRef(javaClass);

		jmethodID *cb_method_ids = new jmethodID[sizeof(g_cb_methods) / sizeof(g_cb_methods[0])];

		//找到系统中所有的回掉方法
		for( int i = 0 ; i < sizeof(g_cb_methods) / sizeof(g_cb_methods[0]);i ++){

			*(cb_method_ids++)  = get_class_method_id(  input_env,
														g_cb_methods[i].packagename,
													    g_cb_methods[i].name,
														g_cb_methods[i].signature);
		}
		//保存回掉函数方法ID为全局变量
		g_java->cb_recog_result = *(--cb_method_ids);

		delete cb_method_ids;

		g_java->first_start = 1;

	}
	//else
		{//常规启动 测试函数调用方法

			char str1[] = "test1,start....";
			char str2[] = "test2,start....";

			callback_java(str1,str2,100);
		}
	 INFOR("test C struct as return!");

	//获取JAVA中的实例类
	 jclass objectClass = (input_env)->FindClass("net/telesing/tsdk/tlib/RecogStatus");

	//获取类中每一个变量的定义
	jfieldID j_ss			 = input_env->GetFieldID(objectClass, "ss", "D");
	jfieldID j_blank_buffer  = input_env->GetFieldID(objectClass, "blankBuffer", "D");
	jfieldID j_recog_stat    = input_env->GetFieldID(objectClass, "recogStat", "I");
#if 0
	//修改状态值准备JAVA获取
	//状态赋值
	recog_status.output_recog_state  = 100;
	recog_status.output_blank_buffer = 0.2;
	recog_status.output_ss           = 0.99;

#endif
	//新建一个对象用于返回到Java中
	jobject status = input_env->AllocObject(objectClass);
#if 0
	//给每一个实例的变量
	input_env -> SetDoubleField(status, j_ss,recog_status.output_ss  );
	input_env -> SetDoubleField(status, j_blank_buffer,recog_status.output_blank_buffer);
	input_env -> SetIntField(status, j_recog_stat,recog_status.output_recog_state );
#endif
	return status;
}

static CER_INFOR g_cer_infor[] = {
		{"section"   ,"Ljava/lang/String;"},
		{"expiration","Ljava/lang/String;"},
		{"authority" ,"Ljava/lang/String;"},
//		{"appendData","Ljava/lang/String;"},不能外面获取的
		{"ID"        ,"Ljava/lang/String;"},
		{"sectSrc"   ,"Ljava/lang/String;"},
		{"orgID"     ,"Ljava/lang/String;"},
		{"genrTime"  ,"Ljava/lang/String;"},
		{"genrType"  ,"Ljava/lang/String;"},
		{"genrIp"    ,"Ljava/lang/String;"},
};
//***************************************************************************
//函数名称：
//函数功能：
//输入参数：
//输出参数：
//备	        注 ：没有填写算法,不管你TM输入的是啥,我都TM的返回一个规定的CER
//
//**************************************************************************
JOBJECT native_decrypt_cer(JNIEnv *env, jobject obj, jstring str, jint length){

	INFOR("33333333native_decrypt_cer------>");
	jfieldID jfield_cer;
	jstring  jstringID;
	 jstring jstrTmp = env->NewStringUTF("ZZZ");
	//获取JAVA中的实例类
	 jclass objectClass = env->FindClass("net/telesing/tsdk/tlib/CerInfor");

	 //申请到用于返回的cer
	 jobject cer		= env->AllocObject(objectClass);

	 //简单改变下申请到的数据准备返回给JAVA用
	 for(int i = 0;i < sizeof(g_cer_infor)/sizeof(g_cer_infor[0]);i ++){

		//获取标签并存储
		 jfield_cer = env->GetFieldID(objectClass, g_cer_infor[i].name,g_cer_infor[i].signature);

		//意思下,修改下返回,不然会说没写
		 env->SetObjectField(cer, jfield_cer,jstrTmp);
	 }
	 return cer;
}
//***************************************************************************
//函数名称：
//函数功能：
//输入参数：
//输出参数：
//备	        注 ：CerInfor 中的每一个字段一定要保证全部填写完整,
//		   GetStringUTFChars如果没有正确的字符串传入回内存越界错误
//**************************************************************************
JSTRING native_encrypt_cer(JNIEnv *env, jobject obj, jobject cer, jint length){

	INFOR("[native_encrypt_cer]: ---->");

	jfieldID jfield_cer;
	jstring  jstringID;
	 char cer_data[255];
	//指针数组存放回来的
	char *cer_char;
	memset(cer_data,0,255*sizeof(char));
	//获取Java中的RecogCfg实例类
	jclass objectClass  = env->FindClass("net/telesing/tsdk/tlib/CerInfor");

	//获取RecogCfg类中每一个变量的定义
	for(int i = 0;i < sizeof(g_cer_infor)/sizeof(g_cer_infor[0]);i ++){

		//获取标签并存储
		 jfield_cer = env->GetFieldID(objectClass, g_cer_infor[i].name,g_cer_infor[i].signature);

		//转换成jstring
		 jstringID  = (jstring)env->GetObjectField(cer, jfield_cer);

		if( jstringID == NULL){
			return 	env->NewStringUTF("XXXXXXXXERROR CER IS NOT VAILD---->XXXXXXX");
		}

		//转换成char *存放在本地指针
		  cer_char  = (char*)env->GetStringUTFChars(jstringID,NULL);

		//模拟加密直接把数据连接起来,原封不动返回
		  strcat(cer_data,cer_char);
	}

	__android_log_print(ANDROID_LOG_INFO, "NATIVE:","cer_data    = %s", cer_data);
	INFOR("CER OK");
#define 	 RELEASE
#ifndef RELEASE

	__android_log_print(ANDROID_LOG_INFO, "NATIVE:"," g_java->cer.expiration = %s :", g_java->cer.expiration);
	__android_log_print(ANDROID_LOG_INFO, "NATIVE:"," g_java->cer.authority  = %s :", g_java->cer.authority);
	__android_log_print(ANDROID_LOG_INFO, "NATIVE:"," g_java->cer.ID         = %s :", g_java->cer.id);
	__android_log_print(ANDROID_LOG_INFO, "NATIVE:"," g_java->cer.orgID      = %s :", g_java->cer.org_id);
	__android_log_print(ANDROID_LOG_INFO, "NATIVE:"," g_java->cer.sectSrc    = %s :", g_java->cer.sect_src);
	__android_log_print(ANDROID_LOG_INFO, "NATIVE:"," g_java->cer.genrTime   = %s :", g_java->cer.genr_time);
	__android_log_print(ANDROID_LOG_INFO, "NATIVE:"," g_java->cer.genrType   = %s :", g_java->cer.genr_type);
	__android_log_print(ANDROID_LOG_INFO, "NATIVE:"," g_java->cer.genrIp     = %s :", g_java->cer.genr_ip);

#endif

	return (env->NewStringUTF(cer_data));
 }
//***************************************************************************
//
//							自动注册函数列表
//
//***************************************************************************

static JNINativeMethod g_methods[] = {

	{ "encryptCer"       , "(Lnet/telesing/tsdk/tlib/CerInfor;I)Ljava/lang/String;",(void*)native_encrypt_cer},
	{ "decryptCer"       , "(Ljava/lang/String;I)Lnet/telesing/tsdk/tlib/CerInfor;",(void*)native_decrypt_cer},
  //{ "bindCer"          , " ",(void*)native_binder},
  //{ "unbindCer"        , " ",(void*)native_unbinder},
  //{ "isBindCer"        , " ",(void*)native_is_bind_cer},
  //{ "getSectionsStatus", " ",(void*)native_get_sections_status},
  //{ "genrWave"         , " ",(void*)native_genr_wave},
  //{ "initRecog"        , " ",(void*)native_init_recog},
  //{ "startRecog"       , " ",(void*)native_start_recog},
  //{ "pauseRecog"       , " ",(void*)native_pause_recog},
  //{ "restartRecog"     , " ",(void*)native_restart_recog},
  //{ "stopRecog"        , " ",(void*)native_stop_recog},
  //{ "writeRecog"       , " ",(void*)native_wrire_recog},
  //{ "setRecogConfig"   , " ",(void*)native_set_recog_config},
  //{ "getRecogConfig"   , " ",(void*)native_get_recog_config},
	{ "getRecogStatus", "()Lnet/telesing/tsdk/tlib/RecogStatus;", (void*)native_get_recog_status },


};
//***************************************************************************
//函数名称：registerNativeMethods
//函数功能：注册单个本地方法到虚拟机中
//输入参数：方法数组
//输出参数：
//备	         注 ：
//			clazz = env->FindClass(env, className); C中间使用的方法
//			clazz = env->FindClass(className);//C++使用的方法
//			if (env->RegisterNatives(env, clazz, gMethods, numMethods) < 0) {
//			if (env->RegisterNatives( clazz, gMethods, numMethods) < 0) {
//**************************************************************************

static int register_native_methods(JNIEnv* env, const char* className,
								   JNINativeMethod* g_methods,
								   int num_methods)
{
	jclass clazz;

	clazz = env->FindClass(className);//C++使用的方法
	if (clazz == NULL) {
		return JNI_FALSE;
	}
	if (env->RegisterNatives(clazz, g_methods, num_methods) < 0) {
		return JNI_FALSE;
	}

	return JNI_TRUE;
}
//***************************************************************************
//函数名称：
//函数功能：根据本地函数列表指正,注册函数到VM中
//输入参数：JVM虚拟机
//输出参数：
//备	         注 ：
//
// 			if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_4) != JNI_OK)
//			if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK)
//**************************************************************************
static int register_natives(JNIEnv* env)
{
    if (!register_native_methods(env, JNIREG_CLASS, g_methods,
        sizeof(g_methods) / sizeof(g_methods[0])))

        return JNI_FALSE;

    return JNI_TRUE;
}
//***************************************************************************
//函数名称：
//函数功能：
//输入参数：
//输出参数：
//备	         注 ：
//			!自动注册本地函数
//			!申请java对象的使用的空间,一个结构体
// 			if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_4) != JNI_OK)
//			if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK)
//**************************************************************************

JINT JNI_OnLoad(JavaVM *vm, void *reserved)
 {
	 //用于保存全局的JAVA数据结构体
	 g_java= new JAVA;
	 g_java->first_start = 0;

	JNIEnv* env = NULL;

	 // 获取JNI版本
	if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK){

		return JNI_FALSE;

	}
	 //注册本地函数
	if (!register_natives(env)){

		return JNI_FALSE;
	}

	return JNI_VERSION_1_4;

 }
 //***************************************************************************
 //函数名称：JNI_OnUnload
 //函数功能：虚拟机清理函数
 //输入参数：
 //输出参数：
 //备	 注 ：
 //
 //			清理申请的全局引用空间
 //**************************************************************************
JVOID JNI_OnUnload(JavaVM* vm, void* reserved){

	 delete g_java;
 }

#ifdef __cplusplus
}
#endif
